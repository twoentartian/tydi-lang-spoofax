module streamlet

imports signatures/streamlet-sig
imports base
imports logical_type

signature
  sorts 
    PORT_DIRECTION
  constructors
    In : PORT_DIRECTION
    Out : PORT_DIRECTION
    
    StreamLetType : scope * ID * list(TYPE) -> TYPE
    ImplementationType : scope * ID * list(TYPE) -> TYPE
    InstanceType : ID * TYPE -> TYPE
    EmptyInstanceType : TYPE
    
    PortType : ID * LOGICAL_DATA_TYPE * PORT_DIRECTION -> TYPE
    PortArrayType : ID * LOGICAL_DATA_TYPE * PORT_DIRECTION -> TYPE
rules
///////////////////////////////////////////// declare streamlet /////////////////////////////////////////////
  streamletOk : scope * StreamLet
  streamletOk(s, StreamLet(x, args, bodys)) :- {streamletScope streamletType argTypes}
    new streamletScope, streamletScope -StreamletScope-> s,
    streamletType == StreamLetType(streamletScope, x, argTypes),
    streamletArgsToTypes(s, streamletScope, args) == argTypes,
    declareStreamlet(s, x, streamletType),
    streamletBodysOk(streamletScope, bodys).
  
  streamletArgsToTypes : scope * scope * StreamLetArgs -> list(TYPE)
  streamletArgsToTypes(s, streamletS, NoStreamLetArg()) = [].
  streamletArgsToTypes(s, streamletS, SomeStreamLetArgs(args)) = types :-
    types == argsToTypes(s, args),
    declareArgs(streamletS, args).

  argToType : scope * Arg -> TYPE
  argsToTypes maps argToType(*, list(*)) = list(*)
  argToType(s, ArgLogicalType(x)) = EmptyLogicalDataType().
  argToType(s, ArgValue(x, basicT)) = T :-
    typeOfBasicType(basicT) == T.
  argToType(s, ArgInstancecType(x)) = EmptyInstanceType().
  
  declareArg : scope * Arg
  declareArgs maps declareArg(*,list(*))
  declareArg(s, ArgLogicalType(x)) :-
    declareLogicalType(s, x, EmptyLogicalData()).
  declareArg(s, ArgValue(x, basicT)) :- {T}
    typeOfBasicType(basicT) == T,
    declareConst(s, x, T).
  declareArg(s, ArgInstancecType(x)) :-
    declareInstance(s, x, EmptyInstanceType()).
  
  allowStreamletPortType : LOGICAL_DATA_TYPE
  allowStreamletPortType(EmptyLogicalData()).//used for template streamlet args.
  allowStreamletPortType(DataStreamType(_,_)).
  streamletBodyOk : scope * StreamLetBody
  streamletBodysOk maps streamletBodyOk(*,list(*))
  streamletBodyOk(streamletS, StreamLetPort(x, logicalT, dir)) :- {T}
    typeOfLogicalType(streamletS, logicalT) == T,
    allowStreamletPortType(T) | error $[[T] must a stream type],
    declarePort(streamletS, x, T, dirOf(dir)).
  streamletBodyOk(streamletS, StreamLetPortArray(x, logicalT, lenExp, dir)) :- {T}
    typeOfLogicalType(streamletS, logicalT) == T,
    allowStreamletPortType(T) | error $[[T] must a stream type],
    declarePort(streamletS, x, T, dirOf(dir)),
    typeOfExp(streamletS, lenExp) == Int().
    
  dirOf : Direction -> PORT_DIRECTION
  dirOf(DirIn()) = In().
  dirOf(DirOut()) = Out().
  
///////////////////////////////////////////// declare implementation /////////////////////////////////////////////
  implementationOk : scope * Implementation
  implementationOk(s,Implementation(x, args, streamletX, streamletArgExps, implBody)) :- {implementationScope implmentationType argTypes streamletT streamletArgTypes streamletS}
    new implementationScope, implementationScope -ImplementationScope-> s,
    implmentationType == ImplementationType(implementationScope, x, argTypes),
    implmentationArgsToTypes(s, implementationScope, args) == argTypes,
    implementationBodysOk(implementationScope, implBody),
    typeOfStreamletRef(implementationScope, streamletX) == StreamLetType(streamletS,streamletX,streamletArgTypes),
    verifyArgExps(implementationScope, streamletArgExps, streamletArgTypes),
    declareInstance(implementationScope, "self", InstanceType("self",implmentationType)),
    declareConst(implementationScope, "!streamlet", StreamLetType(streamletS, streamletX, streamletArgTypes)),
    declareImplement(s, x, implmentationType).
  
  verifyArgExps : scope * ArgExps * list(TYPE)
  verifyArgExps(s, EmptyStreamLetArgExps(), []).
  verifyArgExps(s, SomeStreamLetArgExps(argExps), types) :- 
    verifyArgExps_(s, argExps, types).
  
  allowArgPassing : TYPE * TYPE
  allowArgPassing(T,T).
  allowArgPassing(LogicalDataType(_),EmptyLogicalDataType()).
  allowArgPassing(InstanceType(_,_),EmptyInstanceType()).
  
  verifyArgExp : scope * ArgExp * TYPE
  verifyArgExps_ maps verifyArgExp(*,list(*),list(*))
  verifyArgExp(s, ConstExp(e), t) :- {argT}
    argT == typeOfExp(s,e),
    allowArgPassing(argT,t) | error $[Arg type mismatch(const), argT: [argT] expected: [t] ].
  verifyArgExp(s, TypeExp(e), t) :- {logicalT argT}
    typeOfLogicalType(s,e) == logicalT,
    LogicalDataType(logicalT) == argT,
    allowArgPassing(argT,t) | error $[Arg type mismatch(logical datatype), argT: [argT] expected: [t] ].
  verifyArgExp(s, InstanceExp(x), t) :- {argT}
    argT == typeOfImplementRef(s,x),
    allowArgPassing(argT, t) | error $[Arg type mismatch(instancec), argT: [argT] expected: [t] ].
  
  implmentationArgsToTypes : scope * scope * ImplementationArgs -> list(TYPE)
  implmentationArgsToTypes(s, implementationS, NoImplementationArgs()) = [].
  implmentationArgsToTypes(s, implementationS, ImplementationArgs(args)) = types :-
    types == argsToTypes(s, args),
    declareArgs(implementationS, args).
  
  notSameID : ID * ID
  notSameID(x,x) :- false.
  notSameID(x,y).
  
  checkNonNestedSelfInstance : scope * ID
  checkNonNestedSelfInstance(implS, implName) :- {implX}
    typeOfInstanceRefInCurrentScope(implS, "self") == InstanceType(_, ImplementationType(_, implX, _)) ,
    notSameID(implX, implName).
  
  implementationBodyOk : scope * ImplementationBody
  implementationBodysOk maps implementationBodyOk(*,list(*))
  implementationBodyOk(implS, DeclareInstance(instX, implName, implArgs)) :- {targetImplS targetImplArgTypes implT}
    typeOfImplementRef(implS, implName) == implT,
    implT == ImplementationType(targetImplS, implName, targetImplArgTypes),
    declareInstance(implS, instX, InstanceType(instX,implT)),
    verifyArgExps(implS, implArgs, targetImplArgTypes),
    checkNonNestedSelfInstance(implS, implName) | error $[Cannot use an implementation in its defination scope].
    
  implementationBodyOk(implS, DeclareInstanceArray(instX, implName, implArgs, size)) :- {targetImplS targetImplArgTypes implT}
    typeOfImplementRef(implS, implName) == implT,
    implT == ImplementationType(targetImplS, implName, targetImplArgTypes),
    declareInstance(implS, instX, Array(InstanceType(instX,implT))),
    verifyArgExps(implS, implArgs, targetImplArgTypes),
    checkNonNestedSelfInstance(implS, implName) | error $[Cannot use an implementation in its defination scope],
    typeOfExp(implS, size) == Int().
  
  implementationBodyOk(implS, DeclareNet(leftPort, rightPort, netName)).
  implementationBodyOk(implS, DeclareDelayedNet(leftPort, delay, rightPort, netName)).
  
  implementationBodyOk(implS, IfBlock(ifExp,implBody,elif,else)).
  implementationBodyOk(implS, ForBlock(x,arrayExp,implBody)).
  
  
  elifOk : scope * ElifBlock
  elifOk(implS, ElifBlock(e,implBody)) :-
    implementationBodysOk(implS, implBody),
    typeOfExp(implS, e) == Bool().
  
  elseOk : scope * ElseBlock
  elseOk(implS, EmptyElseBlock()).
  elseOk(implS, ElseBlock(implBody)) :-
    implementationBodysOk(implS, implBody).
  
///////////////////////////////////////////// new streamlet /////////////////////////////////////////////
signature
  relations 
    streamlet : ID -> scope
rules
  declareStreamlet : scope * ID * TYPE
  declareStreamlet(s, x, streamletType) :- {streamletS argTypes}
    !streamlet[x, withType(streamletType)] in s,
    resolveStreamletInCurrentScope(s, x) == [(_, (_, _))] | error $[Duplicate definition of streamlet [x]].
  
  resolveStreamlet : scope * ID -> list((path * (ID * scope)))
  resolveStreamlet(s, x) = ps :- 
    query streamlet
      filter (GroupScope | UnionScope | StreamScope | StreamletScope | ImplementationScope)*
        and {x' :- x' == x}
        min $ < GroupScope, $ < UnionScope, GroupScope < UnionScope, UnionScope < StreamScope, StreamScope < StreamletScope, StreamletScope < ImplementationScope 
        and true
         in s |-> ps. //TODO: add scope edge
          
  resolveStreamletInCurrentScope : scope * ID -> list((path * (ID * scope)))
  resolveStreamletInCurrentScope(s, x) = ps :-
    query streamlet
      filter e
         and { x' :- x' == x }
         min 
         and true
          in s |-> ps.
  
  typeOfStreamletRef : scope * ID -> TYPE
  typeOfStreamletRef(s, x) = T :- {x' typeS} 
    resolveStreamlet(s, x) == [(_,(x', typeS))|_]
      | error $[Streamlet [x] not defined with given template args],
    typeOf(typeS) == T,
    @x.type := T,
    @x.ref := x'.

///////////////////////////////////////////// new port /////////////////////////////////////////////
signature
  relations 
    port : ID -> scope
rules
  declarePort : scope * ID * LOGICAL_DATA_TYPE * PORT_DIRECTION
  declarePort(s, x, T, dir) :-
    !port[x, withType(PortType(x, T, dir))] in s,
    resolvePortInCurrentScope(s, x) == [(_, (_, _))] | error $[Duplicate definition of port [x]].
  
  declarePortArray : scope * ID * LOGICAL_DATA_TYPE * PORT_DIRECTION
  declarePortArray(s, x, T, dir) :-
    !port[x, withType(PortArrayType(x, T, dir))] in s,
    resolvePortInCurrentScope(s, x) == [(_, (_, _))] | error $[Duplicate definition of port [x]].
  
  resolvePort : scope * ID -> list((path * (ID * scope)))
  resolvePort(s, x) = ps :- 
    query port
      filter (GroupScope | UnionScope | StreamScope | StreamletScope | ImplementationScope)*
        and {x' :- x' == x}
        min $ < GroupScope, $ < UnionScope, GroupScope < UnionScope, UnionScope < StreamScope, StreamScope < StreamletScope, StreamletScope < ImplementationScope 
        and true
         in s |-> ps. //TODO: add scope edge
          
  resolvePortInCurrentScope : scope * ID -> list((path * (ID * scope)))
  resolvePortInCurrentScope(s, x) = ps :-
    query port
      filter e
         and { x' :- x' == x }
         min 
         and true
          in s |-> ps.
  
  typeOfPortRef : scope * ID -> TYPE
  typeOfPortRef(s, x) = T :- {x' typeS} 
    resolvePort(s, x) == [(_,(x', typeS))|_]
      | error $[Port [x] not defined],
    typeOf(typeS) == T,
    @x.type := T,
    @x.ref := x'.

///////////////////////////////////////////// new implement /////////////////////////////////////////////
signature
  relations 
    implement : ID -> scope
rules
  declareImplement : scope * ID * TYPE
  declareImplement(s, x, streamletType) :-
    !implement[x, withType(streamletType)] in s,
    resolveImplementInCurrentScope(s, x) == [(_, (_, _))] | error $[Duplicate definition of implementation [x]].
  
  resolveImplement : scope * ID -> list((path * (ID * scope)))
  resolveImplement(s, x) = ps :- 
    query implement
      filter (GroupScope | UnionScope | StreamScope | StreamletScope | ImplementationScope)*
        and {x' :- x' == x}
        min $ < GroupScope, $ < UnionScope, GroupScope < UnionScope, UnionScope < StreamScope, StreamScope < StreamletScope, StreamletScope < ImplementationScope 
        and true
         in s |-> ps. //TODO: add scope edge
          
  resolveImplementInCurrentScope : scope * ID -> list((path * (ID * scope)))
  resolveImplementInCurrentScope(s, x) = ps :-
    query implement
      filter e
         and { x' :- x' == x }
         min 
         and true
          in s |-> ps.
  
  typeOfImplementRef : scope * ID -> TYPE
  typeOfImplementRef(s, x) = T :- {x' typeS} 
    resolveImplement(s, x) == [(_,(x', typeS))|_]
      | error $[Implementation [x] not defined],
    typeOf(typeS) == T,
    @x.type := T,
    @x.ref := x'.
    
///////////////////////////////////////////// new instance /////////////////////////////////////////////
signature
  relations 
    instance : ID -> scope
rules
  declareInstance : scope * ID * TYPE
  declareInstance(s, x, instanceType) :-
    !instance[x, withType(instanceType)] in s,
    resolveInstanceInCurrentScope(s, x) == [(_, (_, _))] | error $[Duplicate definition of instance [x]].
  
  resolveInstance : scope * ID -> list((path * (ID * scope)))
  resolveInstance(s, x) = ps :- 
    query instance
      filter (GroupScope | UnionScope | StreamScope | StreamletScope | ImplementationScope)*
        and {x' :- x' == x}
        min $ < GroupScope, $ < UnionScope, GroupScope < UnionScope, UnionScope < StreamScope, StreamScope < StreamletScope, StreamletScope < ImplementationScope 
        and true
         in s |-> ps. //TODO: add scope edge
          
  resolveInstanceInCurrentScope : scope * ID -> list((path * (ID * scope)))
  resolveInstanceInCurrentScope(s, x) = ps :-
    query instance
      filter e
         and { x' :- x' == x }
         min 
         and true
          in s |-> ps.
  
  typeOfInstanceRef : scope * ID -> TYPE
  typeOfInstanceRef(s, x) = T :- {x' typeS} 
    resolveInstance(s, x) == [(_,(x', typeS))|_]
      | error $[Instance [x] not defined],
    typeOf(typeS) == T,
    @x.type := T,
    @x.ref := x'.
    
  typeOfInstanceRefInCurrentScope : scope * ID -> TYPE
  typeOfInstanceRefInCurrentScope(s, x) = T :- {x' typeS} 
    resolveInstanceInCurrentScope(s, x) == [(_,(x', typeS))|_]
      | error $[Instance [x] not defined],
    typeOf(typeS) == T,
    @x.type := T,
    @x.ref := x'.
